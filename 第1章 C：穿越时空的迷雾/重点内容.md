__C语言的出现__


1.1969年，Multics工程--试图建立一个巨大的操作系统，能应用于规模很小的硬件系统中--失败--但为C语言体现“小即是美”铺平了道路。

2.贝尔实验室专家撤离Multics工程--其中一位专家汤普森(Thompson)和同事丹尼斯里奇(Dennis Ritchie)自娱自乐，把汤普森的“太空旅行”软件移植到PDP-7系统上。

3.与此同时，汤普森使用汇编语言为PDP-7编写了一个比Multics简单、轻便得多的新型操作系统--贝尔实验室的Brian Kernighan在1970年给这个操作系统取名为UNIX。

4.用汇编语言编写的UNIX--很笨拙--编制数据结构时会浪费大量时间--系统难以调试--理解起来困难。

5.汤普森想利用高级语言的一些优点--创建了B语言--他把BCPL语言做了简化，使B的解释器能常驻于PDP-7只有8KB大小的内存中。

6.由于硬件系统的内存限制，它只允许放置解释器而不是编译器--由此产生的低效阻碍了使用B语言进行UNIX自身的系统编程--B语言从来不曾真正成功过。

7.B语言保持了BCPL语言无类型的特点，它仅有的操作数就是机器的字--1970年开发平台转移到PDP-11--这种处理器以硬件支持几种不同长度的数据类型为特色--B语言无法表达不同的数据类型，效率
也是问题--无类型语言很快显得不合时宜--汤普森被迫早PDP-11上重新用汇编语言实现了UNIX。

8.丹尼斯里奇利用PDP-11的强大性能，创立了能够同时解决多种数据类型和效率的“New B”语言（它采用了编译模式而不是解释模式，引入了类型系统，而且每个变量在使用前必须先声明）--即后来的C语言。

各种影响-->1965-7 BCPL-->1969 B-->1971 New B-->1972-3 早期的C。

__C语言的早期体验__

增加类型系统的主要目的是帮助编译器设计者区分新型PDP-11机器所拥有的的不同数据类型，由于设计哲学，C排斥强类型，它允许程序员 需要时可以在不同类型的对象间赋值。

除类型系统之外，C语言的许多其他特性是为了方便编译器设计者而建立的（开始几年C语言的主要客户就是那些编译器设计者）。

根据编译器设计者的思路而发展形成的语言特性如下：<br>
1.<br>数组下标从0而不是1开始，因为偏移量的概念在编译器设计者的心中已是根深蒂固。

2.<br>C语言的基本数据类型直接与底层硬件相对应，C语言中不存在内置的复数类型。某种语言要素如果没有得到底层硬件的直接支持，编译器设计者就不会在它上面浪费任何精力。
直到硬件系统能够直接支持浮点数之后C语言才增加了对浮点类型的支持。

3.<br>表达式中的数组名可以看作是指针，把数组当做指针简化了很多东西--不再需要一种复杂的机制去区分它们，把他们传递到一个函数时不必忍受必须复制所有数组内容的低效率。但数组
和指针并不是再任何情况下都是等效的。

4.<br>float被自动扩展为doule，在ANSI C中不再如此。

5.<br>不允许嵌套函数（函数内部包含另一个函数的定义），简化了编译器，并稍微提高了C程序的运行时组织结构。

6.<br>register关键字,一个失误的设计，register关键字简化了编译器，却把包袱丢给了程序员 P5。

C语言对直接由硬件支持的底层操作的强调，带来了极高的效率和移植性，反过来也帮助UNIX获得了巨大的成功。

__标准I/O库和C预处理器__

C编译器不曾实现的一些功能必须通过其他途径实现--C语言没有定义I/O，而是由库函数提供。
<br>C预处理器也几乎被同时加入，它实现的3个主要功能如下：

1.字符串替换，通常用于为常量提供一个符号名。

2.头文件包含(在BCPL中首创)，一般性的声明可以被分离到头文件中，并且可以被许多源文件使用。

3.通用代码模板的扩展，与函数不同，宏在连续几个调用中所接收的参数的类型可以不同(宏的实际参数只是按原样输出)，对宏这样的预处理器，只应该适量使用，

Tips：<br>对C语言预处理器不做太多讨论，C++引入了一些新的方法，使得预处理器几乎无用武之地。<br>宏最好只用于命名常量，并为一些适当的结构提供简洁的记法，宏
名应该大写，这样很容易与函数调用区分开来。

__K&R C以及今日之ANSI C__

0.1972-3 早期的C---1978-9 K&R C---1983-9---ANSI C

1.1978年，Steve Johnson编写了pcc这个可移植的C编译器---开源后被广泛移植，形成了整整一代C编译器的基础。

2.1978年，由Brian Kernighan和Dennis Ritchie编写的《The C Programming Language》出版，这个版本的C语言被称为“K&R C”。

3.20世纪80年代，C语言被业界广泛使用---存在许多不同的实现和差别以及其他并非基于pcc编译器的兴起---一个正式的语言标准是必须的。

4.1983年美国国家标准化组织(ANSI)开始了C语言的标准化工作---确认C语言的常用特性、对语言本身做了一些修改、引入了一些有意义的新特性。

5.国际标组织(ISO)接纳了ANSI C标准但删除了“Rationale”一节并把文档的格式和段落编码作了改动---1990年初ANSI重新采纳ISO C取代了原先版本。

6.从原则上说，ANSI所采纳的C语言标准是ISO C，我们日常所说的标准C也应该是ISO C。

ANSI C标准定义了一些术语用于描述某种编译器的特点：

1.不可移植的代码<br>
  由编译器定义的，即由编译器设计者决定采取何种行动，在不同的编译器中所采取的行为可能并不相同；<br>
  未确定的，即在某些正确情况下的做法，标准并未明确规定应该怎样做，如，参数求值的顺序。
  
2.坏代码

未定义的：在某些不正确情况下的做法，标准并未明确规定应该怎样做，例如当一个有符号整数溢出时该采取什么行动。

约束条件：这是一个必须遵守的限制或要求，如果不遵守，那么程序的行为就会变成“未定义的”。

标准规定编译器只有在违反语法规则和约束条件的情况下才会产生错误信息，这意味着所有不属于约束条件的语义规则都可以不遵循，而且这种行为属于未定义行为，未定义的行为可能
会导致系统瘫痪。

3.可移植的代码

严格遵循标准的：只使用已确定的特性、不突破任何由编译器实现的限制、不产生任何依赖由编译器定义的或未确定的或未定义的特性的输出。<br>
一个遵循标准的程序可以依赖某种编译器特有的不可移植的特性。所以一个程序在一个特定的编译器里是遵循标准的，但在另一个编译器里却是不遵循标准的


__小启发__

1.是先有c语言还是先有UNIX？<br>
  UNIX比C语言出现得早（这也是为什么UNIX的系统时间是从1970年1月1日起按秒计算的，因为它就是那时候产生的）。

2.<br>汤普森发明了++和--操作符，并把它加入到PDP-7的B编译器中，自动增/减机制的出现早于PDP-11硬件系统的出现。

3.该用哪个版本的C语言？<br>
  任何学习或使用C语言的人都应当使用ANSI 。
  
__软件信条__

1.<br>编译器设计者的金科玉律：效率(几乎)就是一切<br>编译器的效率包括两个方面：运行效率(代码的运行速度)和编译效率(产生可执行代码的速度)。<br>
除了一些开发和学习环境之外，运行效率起决定性作用，就出现了很多编译优化措施以缩短运行时间或编译时间。<br>编译器设计者通常会提供一些编译器选项，每个程序员可以选择自己想要的优化措施，毕竟如果结果是不正确的，效率再高又有什么意义呢？

