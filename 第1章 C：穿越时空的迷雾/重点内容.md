__C语言的出现__


1.1969年，Multics工程--试图建立一个巨大的操作系统，能应用于规模很小的硬件系统中--失败--但为C语言体现“小即是美”铺平了道路。

2.贝尔实验室专家撤离Multics工程--其中一位专家汤普森(Thompson)和同事丹尼斯里奇(Dennis Ritchie)自娱自乐，把汤普森的“太空旅行”软件移植到PDP-7系统上。

3.与此同时，汤普森使用汇编语言为PDP-7编写了一个比Multics简单、轻便得多的新型操作系统--贝尔实验室的Brian Kernighan在1970年给这个操作系统取名为UNIX。

4.用汇编语言编写的UNIX--很笨拙--编制数据结构时会浪费大量时间--系统难以调试--理解起来困难。

5.汤普森想利用高级语言的一些优点--创建了B语言--他把BCPL语言做了简化，使B的解释器能常驻于PDP-7只有8KB大小的内存中。

6.由于硬件系统的内存限制，它只允许放置解释器而不是编译器--由此产生的低效阻碍了使用B语言进行UNIX自身的系统编程--B语言从来不曾真正成功过。

7.B语言保持了BCPL语言无类型的特点，它仅有的操作数就是机器的字--1970年开发平台转移到PDP-11--这种处理器以硬件支持几种不同长度的数据类型为特色--B语言无法表达不同的数据类型，效率
也是问题--无类型语言很快显得不合时宜--汤普森被迫早PDP-11上重新用汇编语言实现了UNIX。

8.丹尼斯里奇利用PDP-11的强大性能，创立了能够同时解决多种数据类型和效率的“New B”语言（它采用了编译模式而不是解释模式，引入了类型系统，而且每个变量在使用前必须先声明）--即后来的C语言。

各种影响-->1965-7 BCPL-->1969 B-->1971 New B-->1972-3 早期的C。

__C语言的早期体验__

增加类型系统的主要目的是帮助编译器设计者区分新型PDP-11机器所拥有的的不同数据类型，由于设计哲学，C排斥强类型，它允许程序员 需要时可以在不同类型的对象间赋值。

除类型系统之外，C语言的许多其他特性是为了方便编译器设计者而建立的（开始几年C语言的主要客户就是那些编译器设计者）。

根据编译器设计者的思路而发展形成的语言特性如下：<br>
1.<br>数组下标从0而不是1开始，因为偏移量的概念在编译器设计者的心中已是根深蒂固。

2.<br>C语言的基本数据类型直接与底层硬件相对应，C语言中不存在内置的复数类型。某种语言要素如果没有得到底层硬件的直接支持，编译器设计者就不会在它上面浪费任何精力。
直到硬件系统能够直接支持浮点数之后C语言才增加了对浮点类型的支持。

3.<br>表达式中的数组名可以看作是指针，把数组当做指针简化了很多东西--不再需要一种复杂的机制去区分它们，把他们传递到一个函数时不必忍受必须复制所有数组内容的低效率。但数组
和指针并不是再任何情况下都是等效的。

4.<br>float被自动扩展为doule，在ANSI C中不再如此。

5.<br>不允许嵌套函数（函数内部包含另一个函数的定义），简化了编译器，并稍微提高了C程序的运行时组织结构。

6.<br>register关键字,一个失误的设计，register关键字简化了编译器，却把包袱丢给了程序员 P5。

C语言对直接由硬件支持的底层操作的强调，带来了极高的效率和移植性，反过来也帮助UNIX获得了巨大的成功。

__标准I/O库和C预处理器__

C编译器不曾实现的一些功能必须通过其他途径实现--C语言没有定义I/O，而是由库函数提供。
<br>C预处理器也几乎被同时加入，它实现的3个主要功能如下：

1.字符串替换，通常用于为常量提供一个符号名。

2.头文件包含(在BCPL中首创)，一般性的声明可以被分离到头文件中，并且可以被许多源文件使用。

3.通用代码模板的扩展，与函数不同，宏在连续几个调用中所接收的参数的类型可以不同(宏的实际参数只是按原样输出)，对宏这样的预处理器，只应该适量使用，

Tips：<br>对C语言预处理器不做太多讨论，C++引入了一些新的方法，使得预处理器几乎无用武之地。<br>宏最好只用于命名常量，并为一些适当的结构提供简洁的记法，宏
名应该大写，这样很容易与函数调用区分开来。

__K&R C以及今日之ANSI C__

0.1972-3 早期的C---1978-9 K&R C---1983-9---ANSI C

1.1978年，Steve Johnson编写了pcc这个可移植的C编译器---开源后被广泛移植，形成了整整一代C编译器的基础。

2.1978年，由Brian Kernighan和Dennis Ritchie编写的《The C Programming Language》出版，这个版本的C语言被称为“K&R C”。

3.20世纪80年代，C语言被业界广泛使用---存在许多不同的实现和差别以及其他并非基于pcc编译器的兴起---一个正式的语言标准是必须的。

4.1983年美国国家标准化组织(ANSI)开始了C语言的标准化工作---确认C语言的常用特性、对语言本身做了一些修改、引入了一些有意义的新特性。

5.国际标组织(ISO)接纳了ANSI C标准但删除了“Rationale”一节并把文档的格式和段落编码作了改动---1990年初ANSI重新采纳ISO C取代了原先版本。

6.从原则上说，ANSI所采纳的C语言标准是ISO C，我们日常所说的标准C也应该是ISO C。

ANSI C标准定义了一些术语用于描述某种编译器的特点：

1.不可移植的代码<br>
  由编译器定义的，即由编译器设计者决定采取何种行动，在不同的编译器中所采取的行为可能并不相同；<br>
  未确定的，即在某些正确情况下的做法，标准并未明确规定应该怎样做，如，参数求值的顺序。
  
2.坏代码

未定义的：在某些不正确情况下的做法，标准并未明确规定应该怎样做，例如当一个有符号整数溢出时该采取什么行动。

约束条件：这是一个必须遵守的限制或要求，如果不遵守，那么程序的行为就会变成“未定义的”。

标准规定编译器只有在违反语法规则和约束条件的情况下才会产生错误信息，这意味着所有不属于约束条件的语义规则都可以不遵循，而且这种行为属于未定义行为，未定义的行为可能
会导致系统瘫痪。

3.可移植的代码

严格遵循标准的：只使用已确定的特性、不突破任何由编译器实现的限制、不产生任何依赖由编译器定义的或未确定的或未定义的特性的输出。<br>
一个遵循标准的程序可以依赖某种编译器特有的不可移植的特性。所以一个程序在一个特定的编译器里是遵循标准的，但在另一个编译器里却是不遵循标准的

每一个ANSI C必须能够支持：
1.在函数定义中形参数量的上限至少可以达到31个。<br>
2.在函数调用时实参数量的上限至少可以达到31个。<br>
3.在一条源代码行里至少可以有509个字符。<br>
4.在表达式中至少可以支持32层嵌套的括号。<br>
5.long int 的最大值不得小于2147483647。等等<br>
上面的限制实际并不是约束条件，编译器限制通常是一个编译器质量的话题。

__K&R C和ANSI C之间的区别__

1.<br>
第一类区别，是一些新的、非常不同并且很重要的东西。唯一属于这类区别的特性是原型——把形参的类型作为函数声明的一部分，使得编译器很容易根据函数的定义来检查函数的用法。<br>
Tips：函数原型最好不要省略形参名，它们经常能向程序员提供一些有用的信息。

2.<br>
第二类区别是一些新的关键字。

3.<br>
第三类区别被称作“安静的改变”，即原先的某些语言特性仍然合法，但意思有了一些轻微的改变。如现在的预处理规则定义得更加严格，有一条新规则
，就是相邻的字符串字面值会被自动连接在一起。这方面的例子很多，都不是很重要，甚至可以把被忽略。

4.<br>
第四类区别就是除上面3类之外的所有区别，这些区别在现实中几乎不可能碰到。

5.某个“安静的改变”————“寻常算术转换”(省略K&R C的内容)

ANSI C手册第5.2.1.1节 字符和整型（整型升级）<br>
char、short int、或int型位段，包括它们的有符号或无符号变体，以及枚举类型，可以使用在需要int或unsigned int的表达式中。<br>
如果int可以完整表示源类型的所有值(即int是32位)，那么该源类型的值就转换为int，否则转换为unsigned int。这成为整型升级。

第6.2.1.5节 寻常算术转换

如果其中一个操作数的类型是long double ，那么另一个操作数也被转换为long double<br>
如果其中一个操作数的类型是double ，那么另一个操作数也被转换为double<br>
如果其中一个操作数的类型是float ，那么另一个操作数也被转换为float<br>
否则两个操作数进行整型升级并执行下面的规则：<br>
如果其中一个操作数的类型是unsigned long int，那么另一个操作数也被转换为unsigned long int

如果其中一个操作数的类型是long int，另一个操作数的类型是unsigned int，如果long int能够完整表示unsigned int的所有值(即long是32位int是16位)，那么
unsigned int被转换成long int，否则(即long和int均为32位)两个操作数都被转换成unsigned long int

如果其中一个操作数的类型是long int ，那么另一个操作数也被转换为long int<br>
如果其中一个操作数的类型是unsigned int ，那么另一个操作数也被转换为unsigned int<br>
如果以上条件都不满足，那么两个操作数都为int。

6.<br>K&R C采用无符号保留原则，就是当一个无符号类型与int或更小的整型混合使用时，结果类型就是无符号类型。它有时会使一个负数丢失符号位。<br>
ANSI C标准采用值保留原则，就是当把几个整型操作数混合使用时，结果类型既有可能是有符号数也有可能是无符号数，具体取决于操作数的类型的相对大小。
```C
main()
{
    if(-1 < (unsigned char)1)
        printf("-1 less than (unsigned char)1  ANSI");
    else
        printf("-1 NOT less than (unsigned char)1  K&R");
}
```
以下if表达式的值不为真，为什么？
```C
int arrat[] = {23,34,12,17,204,99,16};
main()
{
    int d = -1, x;
    if(d <= sizeof(array)/sizeof(array[0])-2)
        x = array[d+1];
}
```
if语句在signed int 和unsigned int之间测试相等性，d被升级为unsigned int类型，而-1被转换的结果是一个非常巨大的正整数。

Tips：<br>
尽量不要在代码中使用无符号类型，尽量使用像int那样的有符号类型，只有在使用位段和二进制掩码时，才可以用无符号数。<br>
在K&R C的许多特性中，有许多在ANSI C中进行了更新，包括许多所谓“安静的转变”。在这种情况下，代码在两种编译器里都能通过编译，但具体含义稍有差别。

__小启发__

1.是先有c语言还是先有UNIX？<br>
  UNIX比C语言出现得早（这也是为什么UNIX的系统时间是从1970年1月1日起按秒计算的，因为它就是那时候产生的）。

2.<br>汤普森发明了++和--操作符，并把它加入到PDP-7的B编译器中，自动增/减机制的出现早于PDP-11硬件系统的出现。

3.该用哪个版本的C语言？<br>
  任何学习或使用C语言的人都应当使用ANSI 。
  
4.有时候必须非常专注地阅读ANSI C标准才能找到某个问题的答案

```C
foo(const char **p){}

main(int argc, char **argv)
{
    foo(argv);
}
```
编译这段代码，编译器会发出一条警告信息：警告：参数与原型不匹配。

实参char ** argv与形参const char ** p并不相容。<br>
在ANSI C标准某节讲述约束条件的小节中有这么一句话：每个实参都应该具有自己的类型，这样它的值就可以赋值给与它所对应的形参类型的对象(该对象的类型不能含有限定符)。这就是说
参数传递过程类似于赋值。

标准中有关赋值的一个约束条件：要使上述的赋值形式合法，必须满足以下条件之一：<br>
两个操作数都是指向有限定符或无限定符的相容类型的指针，左边指针所指向的类型必须具有右边指针所指向类型的全部限定符。

正是这个条件是的函数调用中实参char * 能够与形参const char * 匹配，下面作合法性说明：<br>
```C
char *cp;
const char *ccp;
ccp = cp;
```
左操作数是一个指向有const限定符的char的指针；<br>
右操作数是一个指向没有限定符的char的指针；<br>
char类型与char类型是相容的，左操作数所指向的类型具有右操作数所指向类型的限定符(无)，再加上自身的限定符(const)。<br>
cp = ccp;就会产生编译警告。

char ** 实参与const char ** 形参是否相容？

标准中有：const float * 类型并不是一个有限定符的类型————它的类型是“指向一个具有const限定符的float类型的指针”，也就是说const限定符是修饰指针所指向的类型，而不是指针本身。

类似地，const char ** 也是一个没有限定符地指针类型。它的类型是“指向有const限定符的char类型的指针的指针”。

由于char ** 和const char ** 都是没有限定符的指针类型，但它们所指向的类型不一样（前者指向char * 后者指向const char * ），所以它们是不相容的。

5.容易混淆的const

在一个符号前加上const限定符只是表示这个符号不能被赋值，但它并不能防止通过程序的内部(甚至是外部)的方法来修改这个值，const最有用之处就是用它来限定函数的形参。<br>
```C
const int limit = 10;
const int limitp = &limit;
int i = 27;
limitp = &i;
```
这段代码表示limitp是一个指向常量整型的指针。这个指针不能用于修改这个整型数，但任何时候，这个指针本身的值却可以改变。const和 * 的组合
通常只用于在数组形式的参数中模拟传值调用。

6.自由软件基金会（FSF）想建立一个UNIX的自由软件实现方案，称为GNU，许多人赞同GNU的哲学，他们设计软件产品，由FSF进行打包并免费发布，
FSF最好的作品之一就是GNU C编译器系列--gcc。

__软件信条__

1.<br>编译器设计者的金科玉律：效率(几乎)就是一切<br>编译器的效率包括两个方面：运行效率(代码的运行速度)和编译效率(产生可执行代码的速度)。<br>
除了一些开发和学习环境之外，运行效率起决定性作用，就出现了很多编译优化措施以缩短运行时间或编译时间。<br>编译器设计者通常会提供一些编译器选项，每个程序员可以选择自己想要的优化措施，毕竟如果结果是不正确的，效率再高又有什么意义呢？

