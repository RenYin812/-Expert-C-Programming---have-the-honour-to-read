__C语言的出现__


1.1969年，Multics工程--试图建立一个巨大的操作系统，能应用于规模很小的硬件系统中--失败--但为C语言体现“小即是美”铺平了道路。

2.贝尔实验室专家撤离Multics工程--其中一位专家汤普森(Thompson)和同事丹尼斯里奇(Dennis Ritchie)自娱自乐，把汤普森的“太空旅行”软件移植到PDP-7系统上。

3.与此同时，汤普森使用汇编语言为PDP-7编写了一个比Multics简单、轻便得多的新型操作系统--贝尔实验室的Brian Kernighan在1970年给这个操作系统取名为UNIX。

4.用汇编语言编写的UNIX--很笨拙--编制数据结构时会浪费大量时间--系统难以调试--理解起来困难。

5.汤普森想利用高级语言的一些优点--创建了B语言--他把BCPL语言做了简化，使B的解释器能常驻于PDP-7只有8KB大小的内存中。

6.由于硬件系统的内存限制，它只允许放置解释器而不是编译器--由此产生的低效阻碍了使用B语言进行UNIX自身的系统编程--B语言从来不曾真正成功过。

7.B语言保持了BCPL语言无类型的特点，它仅有的操作数就是机器的字--1970年开发平台转移到PDP-11--这种处理器以硬件支持几种不同长度的数据类型为特色--B语言无法表达不同的数据类型，效率
也是问题--无类型语言很快显得不合时宜--汤普森被迫早PDP-11上重新用汇编语言实现了UNIX。

8.丹尼斯里奇利用PDP-11的强大性能，创立了能够同时解决多种数据类型和效率的“New B”语言（它采用了编译模式而不是解释模式，引入了类型系统，而且每个变量在使用前必须先声明）--即后来的C语言。

各种影响-->1965-7 BCPL-->1969 B-->1971 New B-->1972-3 早期的C。

__C语言的早期体验__

增加类型系统的主要目的是帮助编译器设计者区分新型PDP-11机器所拥有的的不同数据类型，由于设计哲学，C排斥强类型，它允许程序员 需要时可以在不同类型的对象间赋值。

除类型系统之外，C语言的许多其他特性是为了方便编译器设计者而建立的（开始几年C语言的主要客户就是那些编译器设计者）。

根据编译器设计者的思路而发展形成的语言特性如下：<br>
1.<br>数组下标从0而不是1开始，因为偏移量的概念在编译器设计者的心中已是根深蒂固。

2.<br>C语言的基本数据类型直接与底层硬件相对应，C语言中不存在内置的复数类型。某种语言要素如果没有得到底层硬件的直接支持，编译器设计者就不会在它上面浪费任何精力。
直到硬件系统能够直接支持浮点数之后C语言才增加了对浮点类型的支持。

3.<br>表达式中的数组名可以看作是指针，把数组当做指针简化了很多东西--不再需要一种复杂的机制去区分它们，把他们传递到一个函数时不必忍受必须复制所有数组内容的低效率。但数组
和指针并不是再任何情况下都是等效的。

4.<br>float被自动扩展为doule，在ANSI C中不再如此。

5.<br>不允许嵌套函数（函数内部包含另一个函数的定义），简化了编译器，并稍微提高了C程序的运行时组织结构。

6.<br>register关键字,一个失误的设计，register关键字简化了编译器，却把包袱丢给了程序员 P5。

C语言对直接由硬件支持的底层操作的强调，带来了极高的效率和移植性，反过来也帮助UNIX获得了巨大的成功。

__小启发__

1.是先有c语言还是先有UNIX？<br>
UNIX比C语言出现得早（这也是为什么UNIX的系统时间是从1970年1月1日起按秒计算的，因为它就是那时候产生的）。

2.汤普森发明了++和--操作符，并把它加入到PDP-7的B编译器中，自动增/减机制的出现早于PDP-11硬件系统的出现。

__软件信条__

1.<br>编译器设计者的金科玉律：效率(几乎)就是一切<br>编译器的效率包括两个方面：运行效率(代码的运行速度)和编译效率(产生可执行代码的速度)。<br>
除了一些开发和学习环境之外，运行效率起决定性作用，就出现了很多编译优化措施以缩短运行时间或编译时间。<br>编译器设计者通常会提供一些编译器选项，每个程序员可以选择自己想要的优化措施，毕竟如果结果是不正确的，效率再高又有什么意义呢？

