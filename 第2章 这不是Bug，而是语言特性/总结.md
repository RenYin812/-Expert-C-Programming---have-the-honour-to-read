__太空软件的故事__

语言的细节决定了一种语言到底是可靠的还是容易滋生错误的。

在C语言中，也存在太多含糊之处或近似含糊之处。分析编程语言缺陷的一种方法是把所有的缺陷归于3类：“多做之过”、“误做之过”、“少做之过”。

__多做之过__

“多做之过”就是语言中存在某些不应该存在的特性，这些特性包括容易出错的switch语句、相邻字符串常量的自动连接、缺省全局作用域。

__一.容易出错的switch语句__

__1.__ 由于存在fall through，switch语句会带来麻烦

__(1)__ 一个遵循标准的C编译器至少允许一条switch语句中有257个case标签，这是为了允许switch满足一个8比特字符的所有情况（256个可能的值加EOF）。

__(2)__ default可以出现在case列表的任何位置，但习惯上总把default放在最后，它在其他的case均无法匹配时被选中执行。但如果没有default且所有的
case均不匹配，则整条switch语句便什么也不做。<br>
在C语言中，几乎从来不进行运行时错误检查（对进行解除引用操作的指针进行有效性检查大概是唯一的例外）。<br>
运行时检查与C语言的设计理念相违背，按照C的理念，程序员应该知道自己正在干什么，而且保证自己的所作所为是正确的。

__(3)__ switch存在一些问题，其中之一就是对case可能出现的值太过于放纵了，例如可以在switch的左花括号之后声明一些变量，从而进行一些局部存储的分配。<cr>
在switch语句中为这些变量加上初始值没有什么用处，因为它绝不会被执行---语句从匹配表达式的case开始执行。
  
__(4)__ switch的另一个问题是它内部的任何语句都可以加上标签，并在之执行时跳转到那里，这就有可能破坏程序流的结构化<br>
所有的case都是可选的，任何形式的语句---包括带标签的语句都是允许的，这就意味着有些错误甚至连lint程序也可能无法检测出来。如把default中的字母l打成数字1，它的
实际效果相当于default子句根本不存在于switch语句中，但是它能顺利通过编译不会显示错误。<br>
int i;<br>
switch(i)<br>
{<br>
  case 5+3:do_again:<br>
  case 2:printf("I loop unremittingly\n"); doto do_again;<br>
  defau1t: i++;<br>
  case 3: ;<br>
}<br>
  
__(5)__ 也许switch最大的缺点是它不会在每个case标签后面的语句执行完毕后自动终止，除非遇到break语句。<br>
“fall through”，意思是如果case语句后面不加break，就依次执行下去，以满足某些特殊情况的要求。

__(6)__ break中断了什么<br>
break语句事实上跳出的是最近的那层循环语句或switch语句，不要低估break语句对控制结构的影响。
  
__二.相邻字符串的自动连接__ 

__1.__ ANSI C引入的另一个新特性是“相邻的字符串常量将被自动合并成一个字符串”的约定。<br>
这样省掉了过去在书写多行信息是必须在行末加“\”的做法，后续的字符串可以出现于每行的开头。
```C
//旧风格
printf("A favorite children's book \
is xxxxx \
xxxxx");
```
```C
//新风格
printf("xxxxx"
"xxxxx"
"yyyyy");
```
  
__2.__ 这种自动合并意味着字符串数组在初始化时，如果漏掉了一个逗号，编译器不会发出错误信息，而是悄无声息地把两个字符串合并在一起。
```C
char *available_resouces[] = {
  "color monitor",
  "big disk",
  "Cray"
  "on-line drawing routhines",
};
```
这样不仅原意与之前不同，而且字符串的数目比预期少了一个，这样，如果在程序中修改available_resouces[3]就等于修改了其他的变量。<br>
最后那个字符串末尾的逗号是从最早的C语法中继承下来的东西，不管存在与否都没有什么意义。
  
__三.缺省全局作用域__
  
__1.__ 定义C函数时，在缺省情况下函数的名字是全局可见的。<br>
可以在函数的名字前加个冗余的extern关键字，也可以不加，效果是一样的。<br>
如果想限制一个函数在这个文件之外不可见，就必须加static关键字。
  
__2.__ 根据实际经验，这种缺省的全局可见性多次被证明是个错误，软件对象在大多数情况下应该缺省地采用有限可见性，当程序员需要让它全局可见时，
应该采用显示手段。
  
__3.__ 这种太大范围的全局可见性会与C语言的interpositioning特性相互产生影响。（第5详述）
  
__4.__ 作用域过宽的问题常见于库中，<br>
一个库需要让一个对象在另一个库中可见，唯一的方法是让它变得全局可见，但这样一来，它对于链接到该库的所有对象都是可见的了，<br>
这就是all-or-nothing，一个符号要么全局可见，要么对其他文件都不可见，在C语言中，对信息可见性的选择就是这么有限。
  
  
__误做之过__
  
C语言中属于“误做之过”的特性，就是语言中有误导性质或是不适当的特性。<br>
这些特性有些根C语言的简洁有关（部分与符号的过度复用有关），有些则与操作符的优先级有关。
  
__1.骆驼背上的重载__
  
__(1)__ C语言存在的一个问题就是它太简洁了，仅增加、修改或删除一个字符就会使原先的程序变成另外一个仍然有效却全然不同的程序。<br>
更糟的是，许多符号是被“重载”的---在不同的上下文环境里有不同的意义，甚至有些关键字也因重载而具有好几种意义，这也是C语言的作用域规则对程序员不那么清晰的主要原因。<br>
表2-1符号重载（P37）
  
__(2)__ apple = sizeof(int) * p;
```C
  int main(void)
{
	long long unsigned int apple;
	char c = 'a';
	char *p = &c;
	//apple = sizeof(int) *p;报错(二进制*的操作数无效)
	apple = sizeof((int) *p);
	printf("%llu\n",apple);
	
	return 0;
}
```
一个符号所表达的意思越多，编译器就越难检测到这个符号在你的使用中所存在的异常情况。
  
__2."有些运算符的优先级是错误的"__
  
__(1)__ 哪些C运算符存在错误的优先级？答案是“当按照常规方式使用时，可能引起误会的任何运算符”。<br>
表2-2C语言运算符优先级存在的问题（P38）
  
__(2)__
  
__小启发__

__1.__ 无论什么时候，如果遇见类似malloc(strlen(str));的语句，几乎可以断定它是错误的，因为其他字符串处理库函数几乎都包含一个额外空间，用于容纳字符串结尾的空字符，而
strlen是个例外。

__2.__<br>
一个“L”的NUL用于结束一个ASCII字符串，ASCII字符串中零的位模式被称为“NUL”；<br>
两个“L”的NULL用于表示什么也不指向（空指针），是一个指针值。

__3.__ 使一段代码在第一次执行时的行为与以后执行时不同<br>
对于自动化程序，可以声明静态变量，初始为空格，然后变为逗号，这样就能控制逗号的输出与否了。
```C
generate_initializer(char *string)
{
    static char separator = ' ';
    printf("%c %s \n",separator, string);
    separator = ',';
}
```
  
__软件信条__

__(1)__ 缺省采用“fall through”，在97%的情况下都是错误的<br>
由此产生了一个特殊的注释约定：
```C
case 1: ;//无break
  /*fall through*/
case 2: ;
```

  
