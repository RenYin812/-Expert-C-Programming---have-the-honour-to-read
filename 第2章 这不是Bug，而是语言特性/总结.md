__太空软件的故事__

语言的细节决定了一种语言到底是可靠的还是容易滋生错误的。

在C语言中，也存在太多含糊之处或近似含糊之处。分析编程语言缺陷的一种方法是把所有的缺陷归于3类：“多做之过”、“误做之过”、“少做之过”。

__多做之过__

“多做之过”就是语言中存在某些不应该存在的特性，这些特性包括容易出错的switch语句、相邻字符串常量的自动连接、缺省全局作用域。

__一.容易出错的switch语句__

__1.__ 由于存在fall through，switch语句会带来麻烦

__(1)__ 一个遵循标准的C编译器至少允许一条switch语句中有257个case标签，这是为了允许switch满足一个8比特字符的所有情况（256个可能的值加EOF）。

__(2)__ default可以出现在case列表的任何位置，但习惯上总把default放在最后，它在其他的case均无法匹配时被选中执行。但如果没有default且所有的
case均不匹配，则整条switch语句便什么也不做。<br>
在C语言中，几乎从来不进行运行时错误检查（对进行解除引用操作的指针进行有效性检查大概是唯一的例外）。<br>
运行时检查与C语言的设计理念相违背，按照C的理念，程序员应该知道自己正在干什么，而且保证自己的所作所为是正确的。

__(3)__ switch存在一些问题，其中之一就是对case可能出现的值太过于放纵了，例如可以在switch的左花括号之后声明一些变量，从而进行一些局部存储的分配。<cr>
在switch语句中为这些变量加上初始值没有什么用处，因为它绝不会被执行---语句从匹配表达式的case开始执行。
  
__(4)__ switch的另一个问题是它内部的任何语句都可以加上标签，并在之执行时跳转到那里，这就有可能破坏程序流的结构化<br>
所有的case都是可选的，任何形式的语句---包括带标签的语句都是允许的，这就意味着有些错误甚至连lint程序也可能无法检测出来。如把default中的字母l打成数字1，它的
实际效果相当于default子句根本不存在于switch语句中，但是它能顺利通过编译不会显示错误。<br>
int i;<br>
switch(i)<br>
{<br>
  case 5+3:do_again:<br>
  case 2:printf("I loop unremittingly\n"); doto do_again;<br>
  defau1t: i++;<br>
  case 3: ;<br>
}<br>
  
__(5)__ 也许switch最大的缺点是它不会在每个case标签后面的语句执行完毕后自动终止，除非遇到break语句。<br>
“fall through”，意思是如果case语句后面不加break，就依次执行下去，以满足某些特殊情况的要求。

__(6)__ break中断了什么<br>
break语句事实上跳出的是最近的那层循环语句或switch语句，不要低估break语句对控制结构的影响。
  
__二.相邻字符串的自动连接__ 

__1.__ ANSI C引入的另一个新特性是“相邻的字符串常量将被自动合并成一个字符串”的约定。<br>
这样省掉了过去在书写多行信息是必须在行末加“\”的做法，后续的字符串可以出现于每行的开头。
```C
//旧风格
printf("A favorite children's book \
is xxxxx \
xxxxx");
```
```C
//新风格
printf("xxxxx"
"xxxxx"
"yyyyy");
```
  
__2.__ 这种自动合并意味着字符串数组在初始化时，如果漏掉了一个逗号，编译器不会发出错误信息，而是悄无声息地把两个字符串合并在一起。
```C
char *available_resouces[] = {
  "color monitor",
  "big disk",
  "Cray"
  "on-line drawing routhines",
};
```
这样不仅原意与之前不同，而且字符串的数目比预期少了一个，这样，如果在程序中修改available_resouces[3]就等于修改了其他的变量。<br>
最后那个字符串末尾的逗号是从最早的C语法中继承下来的东西，不管存在与否都没有什么意义。
  
__三.缺省全局作用域__
  
__1.__ 定义C函数时，在缺省情况下函数的名字是全局可见的。<br>
可以在函数的名字前加个冗余的extern关键字，也可以不加，效果是一样的。<br>
如果想限制一个函数在这个文件之外不可见，就必须加static关键字。
  
__2.__ 根据实际经验，这种缺省的全局可见性多次被证明是个错误，软件对象在大多数情况下应该缺省地采用有限可见性，当程序员需要让它全局可见时，
应该采用显示手段。
  
__3.__ 这种太大范围的全局可见性会与C语言的interpositioning特性相互产生影响。（第5详述）
  
__4.__ 作用域过宽的问题常见于库中，<br>
一个库需要让一个对象在另一个库中可见，唯一的方法是让它变得全局可见，但这样一来，它对于链接到该库的所有对象都是可见的了，<br>
这就是all-or-nothing，一个符号要么全局可见，要么对其他文件都不可见，在C语言中，对信息可见性的选择就是这么有限。
  
  
__误做之过__
  
C语言中属于“误做之过”的特性，就是语言中有误导性质或是不适当的特性。<br>
这些特性有些根C语言的简洁有关（部分与符号的过度复用有关），有些则与操作符的优先级有关。
  
__1.骆驼背上的重载__
  
__(1)__ C语言存在的一个问题就是它太简洁了，仅增加、修改或删除一个字符就会使原先的程序变成另外一个仍然有效却全然不同的程序。<br>
更糟的是，许多符号是被“重载”的---在不同的上下文环境里有不同的意义，甚至有些关键字也因重载而具有好几种意义，这也是C语言的作用域规则对程序员不那么清晰的主要原因。<br>
表2-1符号重载（P37）
  
__(2)__ apple = sizeof(int) * p;
```C
  int main(void)
{
	long long unsigned int apple;
	char c = 'a';
	char *p = &c;
	//apple = sizeof(int) *p;报错(二进制*的操作数无效)
	apple = sizeof((int) *p);
	printf("%llu\n",apple);
	
	return 0;
}
```
一个符号所表达的意思越多，编译器就越难检测到这个符号在你的使用中所存在的异常情况。
  
__2."有些运算符的优先级是错误的"__
  
__(1)__ 哪些C运算符存在错误的优先级？答案是“当按照常规方式使用时，可能引起误会的任何运算符”。<br>
表2-2C语言运算符优先级存在的问题（P38）      
  
__3.早期gets()函数中的Bug导致了Internet蠕虫__ 
        
__(1)__ C语言的问题并不局限于语言本身，标准库中的有些程序也具有不安全的语义。
        
__(2)__ gets()函数正式的任务是从流中读入一个字符串，它的调用者会告诉它把读入的字符串放在什么地方。<br>
gets()函数并不检查缓冲区的空间，事实上它也无法检查缓冲区的空间。<br>
如果函数的调用者提供了一个指向堆栈的指针，并且get()函数读入的字符数量超过了缓冲区的空间，gets()函数会将多出来的字符继续写入到堆栈中，这就覆盖了堆栈原先的内容。

__(3)__ gets()函数是个过时函数，在C语言的官方手册中，强烈建议用fgets()函数彻底取代gets()函数<br>
然后ANSI C标准并没有将gets()函数从标准中拿掉，隐藏在C语言中的问题根源没有真正消除。
  
  
__少做之过__
  
属于“少做之过”的特性就是语言应该提供但未能提供的特性，如标准参数处理以及把lint程序错误地从编译器中分离出来。
  
__2.空格——最后的领域__

__(1)__ 如果在“\”字符和回车键之间不小心留下一两个空格就会出现问题（原代码是把下一行当做当前行的延续）。<br>
这个错误很难发现，因为\后面有没有空格在实际代码中根本看不出来。
  
__(2)__ 如果将所有的空格弃之不用，也会陷入麻烦，如z = y+++x;<br>
ANSI C规定了一种逐渐为人所熟知的“maximal munch strategy”(最大一口策略)。这种策略表示，如果下一个标记有超过一种的解释方案，编译器将选取
能组成最长字符序列的方案，上面的例子将被解析为z = y++ +x;但依然有可能陷入麻烦如：z = y+++++x;按照前面的错略将被解析为z = y++ ++ +x;这将引起一个编译错误。
  
__(3)__ 当程序员有两个指向int的指针并想对两个int数据执行除法运算时，代码如下：
```C
ratio = *x/*y;
```
编译器会给出语法错误，因为“/”与“*”紧贴时会被编译器理解成注释的开始部分。

__3.C++的另一种注释形式__
C++引入了//注释符，人们最初以为“//”不会改变任何语法正确的C代码，但：<br>
a //*<br>
//*/ b<br>
上面的代码在标准C中表示/b，在C++中表示a。
  
  
__小启发__

__1.__ 无论什么时候，如果遇见类似malloc(strlen(str));的语句，几乎可以断定它是错误的，因为其他字符串处理库函数几乎都包含一个额外空间，用于容纳字符串结尾的空字符，而
strlen是个例外。

__2.__<br>
一个“L”的NUL用于结束一个ASCII字符串，ASCII字符串中零的位模式被称为“NUL”；<br>
两个“L”的NULL用于表示什么也不指向（空指针），是一个指针值。

__3.__ 使一段代码在第一次执行时的行为与以后执行时不同<br>
对于自动化程序，可以声明静态变量，初始为空格，然后变为逗号，这样就能控制逗号的输出与否了。
```C
generate_initializer(char *string)
{
    static char separator = ' ';
    printf("%c %s \n",separator, string);
    separator = ',';
}
```

__4.__ 计算的次序<br>
大部分编程语言并未明确规定操作数计算的顺序，<br>
之所以未做定义是想让编译器充分利用自身架构的特点，或者充分利用存储于寄存器中的值。<br>
有些专家建议在C语言中牢记两个优先级就够了：乘法和除法先于加法和减法，在涉及其他的操作符时一律加上括号。
	
__软件信条__

__(1)__ 缺省采用“fall through”，在97%的情况下都是错误的<br>
由此产生了一个特殊的注释约定：
```C
case 1: ;//无break
  /*fall through*/
case 2: ;
```

 __5.__  lint是软件的道德准则，应该始终使用lint程序，按照它的道德准则办事。<br>
软件的经济规律显示，越是在开发周期的早期发现Bug，修复它所付出的代价就越小。所以让lint程序取代调试器来执行寻找Bug的额外工作是一笔很合算的投资。
  
__6.__ 即使可以保证你的编程语言100%可靠，你仍然可能成为算法中灾难性Bug的牺牲品。
